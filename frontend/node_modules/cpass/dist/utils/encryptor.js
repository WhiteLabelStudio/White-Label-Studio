"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var crypto = require("crypto");
var scmp = require("scmp");
var MIN_KEY_LENGTH = 16;
var Encryptor = (function () {
    function Encryptor(opts) {
        this.chipherAlgorithm = 'aes-256-cbc';
        if (typeof opts === 'string') {
            opts = {
                key: opts
            };
        }
        var key = opts.key;
        this.verifyHmac = typeof opts.hmac !== 'undefined' ? opts.hmac : true;
        this.debug = typeof opts.debug !== 'undefined' ? opts.debug : false;
        this.reviver = opts.reviver;
        if (!key || typeof key !== 'string') {
            throw new Error('a string key must be specified');
        }
        if (key.length < MIN_KEY_LENGTH) {
            throw new Error('key must be at least ' + MIN_KEY_LENGTH + ' characters long');
        }
        if (this.reviver !== undefined && this.reviver !== null && typeof this.reviver !== 'function') {
            throw new Error('reviver must be a function');
        }
        this.cryptoKey = crypto.createHash('sha256').update(key).digest();
    }
    Encryptor.prototype.hmac = function (text, format) {
        if (format === void 0) { format = 'hex'; }
        return crypto.createHmac('sha256', this.cryptoKey).update(text).digest(format);
    };
    Encryptor.prototype.encrypt = function (obj) {
        var json = JSON.stringify(obj);
        var iv = crypto.randomBytes(16);
        var cipher = crypto.createCipheriv(this.chipherAlgorithm, this.cryptoKey, iv);
        var encryptedJson = cipher.update(json, 'utf8', 'base64') + cipher.final('base64');
        var result = iv.toString('hex') + encryptedJson;
        if (this.verifyHmac) {
            result = this.hmac(result, 'hex') + result;
        }
        return result;
    };
    Encryptor.prototype.decrypt = function (cipherText) {
        if (!cipherText) {
            return null;
        }
        try {
            if (this.verifyHmac) {
                var expectedHmac = cipherText.substring(0, 64);
                cipherText = cipherText.substring(64);
                var actualHmac = this.hmac(cipherText);
                if (!scmp(Buffer.from(actualHmac, 'hex'), Buffer.from(expectedHmac, 'hex'))) {
                    throw new Error('HMAC does not match');
                }
            }
            var iv = new Buffer(cipherText.substring(0, 32), 'hex');
            var encryptedJson = cipherText.substring(32);
            var decipher = crypto.createDecipheriv(this.chipherAlgorithm, this.cryptoKey, iv);
            var json = decipher.update(encryptedJson, 'base64', 'utf8') + decipher.final('utf8');
            return JSON.parse(json, this.reviver);
        }
        catch (e) {
            if (this.debug) {
                console.error('Exception in decrypt (ignored): %s', e);
            }
            return null;
        }
    };
    return Encryptor;
}());
exports.Encryptor = Encryptor;
//# sourceMappingURL=encryptor.js.map